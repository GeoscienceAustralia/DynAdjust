# Compile and build binaries
#
# For updated Intel OneAPI URLs, see:
# https://github.com/oneapi-src/oneapi-ci/blob/master/.github/workflows/build_all.yml

name: Run tests

on:
  workflow_dispatch:
  push:

env:
  WINDOWS_BASEKIT_URL: https://registrationcenter-download.intel.com/akdlm/IRC_NAS/f5881e61-dcdc-40f1-9bd9-717081ac623c/intel-oneapi-base-toolkit-2025.2.1.46_offline.exe
  LINUX_BASEKIT_URL: https://registrationcenter-download.intel.com/akdlm/IRC_NAS/3b7a16b3-a7b0-460f-be16-de0d64fa6b1e/intel-oneapi-base-toolkit-2025.2.1.44_offline.sh

jobs:

  ctest_linux_dyn_openblas:
    name: Build and run ctests on Linux (openblas)
    runs-on: ubuntu-latest
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }} 
      PKGS: >
        libxerces-c-dev xsdcxx libboost-program-options-dev libopenblas-dev liblapacke-dev gmt ghostscript

    steps:

      - name: Show CPU information
        shell: bash
        run: |
          echo "CPU Information:"
          lscpu || true
          echo "---"
          nproc || true

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ env.PKGS }}

      - name: Check branch name
        shell: bash
        run: echo ${{ env.BRANCH_NAME }}
          
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}

      - name: Build with CMake
        run: |
          cmake dynadjust -DBUILD_TESTING=ON
          make -j2
          ls -la bin/
          
      - name: Run tests
        run: |
          set +e
          ctest --timeout 20 2>&1 | tee ctest_output.log
          CTEST_EXIT_CODE=${PIPESTATUS[0]}
          echo "CTEST_EXIT_CODE=$CTEST_EXIT_CODE" >> $GITHUB_ENV
          ctest --rerun-failed --output-on-failure
          exit 0

      - name: Parse test results and create annotations
        if: always()
        shell: bash
        run: |
          if [ -f ctest_output.log ]; then
            # Find the line with "tests passed" and get everything from there to the end
            SUMMARY_LINE=$(grep -n "tests passed" ctest_output.log | head -1 | cut -d: -f1)
            
            if [ -n "$SUMMARY_LINE" ]; then
              # Get the first line (the summary line)
              FIRST_LINE=$(tail -n +$SUMMARY_LINE ctest_output.log | head -1)
              # Get the multiline summary from the tests passed line onwards
              SUMMARY_CONTENT=$(tail -n +$SUMMARY_LINE ctest_output.log | grep -v "Errors while" | tr '\n' '\a')
              # Replace newlines with %0A for GitHub Actions annotation
              SUMMARY_CONTENT=$(echo "$SUMMARY_CONTENT" | tr '\a' '\n' | sed ':a;N;$!ba;s/\n/%0A/g')
              
              # Check if there are failed tests
              if grep -q "tests failed" ctest_output.log; then
                echo "::error title=Test results (openblas): $FIRST_LINE::$SUMMARY_CONTENT"
              else
                echo "::notice title=Test results (openblas): $FIRST_LINE::$SUMMARY_CONTENT"
              fi
            else
              echo "::error title=Test Error::Could not find test summary in ctest output"
            fi
          else
            echo "::error title=Test Error::Could not find ctest output file"
          fi
          
  ctest_linux_dyn_mkl:
    name: Build and run ctests on Linux (mkl)
    runs-on: ubuntu-latest
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }} 
      PKGS: >
        libxerces-c-dev xsdcxx libboost-program-options-dev gmt ghostscript

    steps:

      - name: Show CPU information
        shell: bash
        run: |
          echo "CPU Information:"
          lscpu || true
          echo "---"
          nproc || true

      - name: Generate cache triggers
        shell: bash
        run: |
          echo ONEAPI_HASH=$(echo "${LINUX_BASEKIT_URL}" | md5sum | cut -f 1 -d" ") >> $GITHUB_ENV

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ env.PKGS }}

      - name: Cache Intel OneAPI
        id: cache-oneapi
        uses: actions/cache@v4
        with:
          path: /opt/intel
          key: intel-oneapi-linux-${{ env.ONEAPI_HASH }}

      - name: Install Intel OneAPI
        if: steps.cache-oneapi.outputs.cache-hit != 'true'
        run: |
          curl -L $LINUX_BASEKIT_URL -o install.sh
          sudo sh install.sh -a --action install --components intel.oneapi.lin.mkl.devel --eula=accept -s

      - name: Check branch name
        shell: bash
        run: echo ${{ env.BRANCH_NAME }}

      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}

      - name: Build with CMake
        run: |
          source /opt/intel/oneapi/setvars.sh
          cmake dynadjust -DBUILD_TESTING=ON
          make -j2
          ls -la bin/
          
      - name: Run tests
        run: |
          source /opt/intel/oneapi/setvars.sh
          #export MKL_VERBOSE=1
          #export MKL_NUM_THREADS=1
          #export OMP_NUM_THREADS=1
          #export MKL_DOMAIN_NUM_THREADS="MKL_DOMAIN_ALL=1"
          set +e
          ctest --timeout 20 2>&1 | tee ctest_output.log
          CTEST_EXIT_CODE=${PIPESTATUS[0]}
          echo "CTEST_EXIT_CODE=$CTEST_EXIT_CODE" >> $GITHUB_ENV
          ctest --rerun-failed --output-on-failure
          exit 0

      - name: Parse test results and create annotations
        if: always()
        shell: bash
        run: |
          if [ -f ctest_output.log ]; then
            # Find the line with "tests passed" and get everything from there to the end
            SUMMARY_LINE=$(grep -n "tests passed" ctest_output.log | head -1 | cut -d: -f1)
            
            if [ -n "$SUMMARY_LINE" ]; then
              # Get the first line (the summary line)
              FIRST_LINE=$(tail -n +$SUMMARY_LINE ctest_output.log | head -1)
              # Get the multiline summary from the tests passed line onwards
              SUMMARY_CONTENT=$(tail -n +$SUMMARY_LINE ctest_output.log | grep -v "Errors while running" | tr '\n' '\a')
              # Replace newlines with %0A for GitHub Actions annotation
              SUMMARY_CONTENT=$(echo "$SUMMARY_CONTENT" | tr '\a' '\n' | sed ':a;N;$!ba;s/\n/%0A/g')
              
              # Check if there are failed tests
              if grep -q "tests failed" ctest_output.log; then
                echo "::error title=Test results (mkl): $FIRST_LINE::$SUMMARY_CONTENT"
              else
                echo "::notice title=Test results (mkl): $FIRST_LINE::$SUMMARY_CONTENT"
              fi
            else
              echo "::error title=Test Error::Could not find test summary in ctest output"
            fi
          else
            echo "::error title=Test Error::Could not find ctest output file"
          fi

  test_linux_mkl_binaries:
    name: Test Linux MKL binaries from build workflow
    runs-on: ubuntu-latest
    needs: []  # Don't depend on other test jobs
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
      PKGS: >
        libxerces-c-dev xsdcxx libboost-program-options-dev
    
    steps:
      - name: Show CPU information
        shell: bash
        run: |
          echo "CPU Information:"
          lscpu || true
          echo "---"
          nproc || true

      - name: Generate cache triggers
        shell: bash
        run: |
          echo ONEAPI_HASH=$(echo "${LINUX_BASEKIT_URL}" | md5sum | cut -f 1 -d" ") >> $GITHUB_ENV

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ env.PKGS }}

      - name: Cache Intel OneAPI
        id: cache-oneapi
        uses: actions/cache@v4
        with:
          path: /opt/intel
          key: intel-oneapi-linux-all-${{ env.ONEAPI_HASH }}

      - name: Install Intel OneAPI
        if: steps.cache-oneapi.outputs.cache-hit != 'true'
        run: |
          curl -L $LINUX_BASEKIT_URL -o install.sh
          #sudo sh install.sh -a --action install --components intel.oneapi.lin.mkl.devel --eula=accept -s
          sudo sh install.sh -a --action install --eula=accept -s

      - name: Check branch name
        shell: bash
        run: echo ${{ env.BRANCH_NAME }}
        
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}
      
      - name: Download MKL binaries artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build.yml
          workflow_conclusion: success
          name: dynadjust-linux-mkl
          path: ./artifacts
          branch: ${{ env.BRANCH_NAME }}
          if_no_artifact_found: fail
      
      - name: Extract and prepare binaries
        run: |
          # Create bin directory
          mkdir -p ./bin/
          
          # Extract the binaries from the downloaded artifact
          if [ -d "./artifacts/dynadjust-linux-mkl" ]; then
            mv ./artifacts/dynadjust-linux-mkl/* ./bin/
          else
            # Fallback in case directory structure is different
            find ./artifacts -type f -executable -exec mv {} ./bin/ \;
          fi
          
          # Make sure binaries are executable
          chmod +x ./bin/*
          
          # Create symlinks for the expected binary names
          cd bin
          for binary in *; do
            # Create symlink without 'dna' prefix if it exists
            if [[ $binary == dna* ]]; then
              ln -sf "$binary" "${binary#dna}"
            fi
          done
          cd ..
          
          ls -la ./bin/
      
      - name: Run GNSS network test
        working-directory: ./sampleData
        run: |
          # Source Intel OneAPI environment
          source /opt/intel/oneapi/setvars.sh
          
          # Modify PATH to use our binaries
          export PATH="../bin:$PATH"
          
          # Run the test script and capture output
          set +e  # Don't exit on error
          bash run-gnss-network.sh 2>&1 | tee gnss_test_output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check if Chi-Square test has the expected values
          if grep -q "0.843 < 1.165 < 1.170" gnss_test_output.log; then
            echo "Chi-Square test values match (0.843 < 1.165 < 1.170) - test considered successful"
            exit 0
          else
            # If Chi-Square values not found, use original exit code
            echo "GNSS network test exit code: $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          fi
      
      - name: Run urban network test  
        working-directory: ./sampleData
        run: |
          # Source Intel OneAPI environment
          source /opt/intel/oneapi/setvars.sh
          
          # Modify PATH to use our binaries
          export PATH="../bin:$PATH"
          
          # Run the test script and capture output
          set +e  # Don't exit on error
          bash run-urban-network.sh 2>&1 | tee urban_test_output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check if Chi-Square test has the expected values
          if grep -q "0.901 < 0.857 < 1.104" urban_test_output.log; then
            echo "Chi-Square test values match (0.901 < 0.857 < 1.104) - test considered successful"
            exit 0
          else
            # If Chi-Square values not found, use original exit code
            echo "Urban network test exit code: $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          fi

  test_linux_openblas_binaries:
    name: Test Linux OpenBLAS static binaries from build workflow
    runs-on: ubuntu-latest
    needs: []  # Don't depend on other test jobs
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
    
    steps:
      - name: Show CPU information
        shell: bash
        run: |
          echo "CPU Information:"
          lscpu || true
          echo "---"
          nproc || true

      - name: Check branch name
        shell: bash
        run: echo ${{ env.BRANCH_NAME }}
        
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}
      
      - name: Download static binaries artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build.yml
          workflow_conclusion: success
          name: dynadjust-linux-openblas-static
          path: ./artifacts
          branch: ${{ env.BRANCH_NAME }}
          if_no_artifact_found: fail
      
      - name: Extract and prepare binaries
        run: |
          # Create bin directory
          mkdir -p ./bin/
          
          # Extract the binaries from the downloaded artifact
          if [ -d "./artifacts/dynadjust-linux-static" ]; then
            mv ./artifacts/dynadjust-linux-static/* ./bin/
          else
            # Fallback in case directory structure is different
            find ./artifacts -type f -executable -exec mv {} ./bin/ \;
          fi
          
          # Make sure binaries are executable
          chmod +x ./bin/*
          
          # Create symlinks for the expected binary names
          cd bin
          for binary in *; do
            # Create symlink without 'dna' prefix if it exists
            if [[ $binary == dna* ]]; then
              ln -sf "$binary" "${binary#dna}"
            fi
          done
          cd ..
          
          ls -la ./bin/
      
      - name: Run GNSS network test
        working-directory: ./sampleData
        run: |
          # Modify PATH to use our static binaries
          export PATH="../bin:$PATH"
          
          # Run the test script and capture output
          set +e  # Don't exit on error
          bash run-gnss-network.sh 2>&1 | tee gnss_test_output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check if Chi-Square test has the expected values
          if grep -q "0.843 < 1.165 < 1.170" gnss_test_output.log; then
            echo "Chi-Square test values match (0.843 < 1.165 < 1.170) - test considered successful"
            exit 0
          else
            # If Chi-Square values not found, use original exit code
            echo "GNSS network test exit code: $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          fi
      
      - name: Run urban network test  
        working-directory: ./sampleData
        run: |
          # Modify PATH to use our static binaries
          export PATH="../bin:$PATH"
          
          # Run the test script and capture output
          set +e  # Don't exit on error
          bash run-urban-network.sh 2>&1 | tee urban_test_output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check if Chi-Square test has the expected values
          if grep -q "0.901 < 0.857 < 1.104" urban_test_output.log; then
            echo "Chi-Square test values match (0.901 < 0.857 < 1.104) - test considered successful"
            exit 0
          else
            # If Chi-Square values not found, use original exit code
            echo "Urban network test exit code: $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          fi

  test_macos_static_binaries:
    name: Test macOS static binaries from build workflow
    runs-on: macos-latest
    needs: []  # Don't depend on other test jobs
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
    
    steps:
      - name: Show CPU information
        shell: bash
        run: |
          echo "CPU Information:"
          sysctl -n machdep.cpu.brand_string || true
          echo "---"
          sysctl -n hw.ncpu || true

      - name: Check branch name
        shell: bash
        run: echo ${{ env.BRANCH_NAME }}
        
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}
      
      - name: Download static binaries artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build.yml
          workflow_conclusion: success
          name: dynadjust-macos-static
          path: ./artifacts
          branch: ${{ env.BRANCH_NAME }}
          if_no_artifact_found: fail
      
      - name: Extract and prepare binaries
        run: |
          # Create bin directory
          mkdir -p ./bin/
          
          # Move binaries from artifacts directory
          if [ -d "./artifacts" ]; then
            mv ./artifacts/* ./bin/ 2>/dev/null || true
          fi
          
          # Make sure binaries are executable
          chmod +x ./bin/* 2>/dev/null || true
          
          # Create symlinks for the expected binary names
          cd bin
          for binary in *; do
            # Create symlink without 'dna' prefix if it exists
            if [[ $binary == dna* ]]; then
              ln -sf "$binary" "${binary#dna}"
            fi
          done
          cd ..
          
          ls -la ./bin/
      
      - name: Run GNSS network test
        working-directory: ./sampleData
        run: |
          # Modify PATH to use our static binaries
          export PATH="../bin:$PATH"
          
          # Run the test script and capture output
          set +e  # Don't exit on error
          bash run-gnss-network.sh 2>&1 | tee gnss_test_output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check if Chi-Square test has the expected values
          if grep -q "0.843 < 1.165 < 1.170" gnss_test_output.log; then
            echo "Chi-Square test values match (0.843 < 1.165 < 1.170) - test considered successful"
            exit 0
          else
            # If Chi-Square values not found, use original exit code
            echo "GNSS network test exit code: $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          fi
      
      - name: Run urban network test  
        working-directory: ./sampleData
        run: |
          # Modify PATH to use our static binaries
          export PATH="../bin:$PATH"
          
          # Run the test script and capture output
          set +e  # Don't exit on error
          bash run-urban-network.sh 2>&1 | tee urban_test_output.log
          TEST_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check if Chi-Square test has the expected values
          if grep -q "0.901 < 0.857 < 1.104" urban_test_output.log; then
            echo "Chi-Square test values match (0.901 < 0.857 < 1.104) - test considered successful"
            exit 0
          else
            # If Chi-Square values not found, use original exit code
            echo "Urban network test exit code: $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          fi

  test_windows_mkl_binaries:
    name: Test Windows MKL binaries from build workflow
    runs-on: windows-latest
    needs: []  # Don't depend on other test jobs
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
      VCPKG_PACKAGES: boost-geometry boost-process boost-iostreams boost-spirit boost-system boost-program-options boost-interprocess xerces-c
      VCPKG_INSTALLATION_ROOT: "C:/vcpkg"
      VCPKG_BINARY_SOURCES: "clear"
      ONEAPI_VERSION: "2025.2"
    
    steps:
      - name: Show CPU information
        shell: powershell
        run: |
          Write-Host "CPU Information:"
          Get-WmiObject -Class Win32_Processor | Select-Object Name, NumberOfCores, NumberOfLogicalProcessors | Format-List

      - name: Generate cache triggers
        shell: bash
        run: |
          echo VCPKG_HASH=$(echo "${VCPKG_PACKAGES}" | sed "s/ /_/g" | md5sum | cut -f 1 -d" ") >> $GITHUB_ENV
          echo ONEAPI_HASH=$(echo "${WINDOWS_BASEKIT_URL}" | md5sum | cut -f 1 -d" ") >> $GITHUB_ENV

      - name: Cache vcpkg
        id: cache-vcpkg
        uses: actions/cache@v4
        with:
          path: ${{ env.VCPKG_INSTALLATION_ROOT }}/installed
          key: vcpkg-${{ runner.os }}-${{ env.VCPKG_HASH }}

      - name: Cache Intel OneAPI
        id: cache-oneapi
        uses: actions/cache@v4
        with:
          path: C:\Program Files (x86)\Intel\oneAPI
          key: intel-oneapi-${{ env.ONEAPI_HASH }}

      - name: Install vcpkg prerequisites
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          vcpkg.exe --triplet=x64-windows install ${{ env.VCPKG_PACKAGES }}
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/.git
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/buildtrees
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/downloads
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/.github
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/docs

      - name: Install Intel OneAPI
        if: steps.cache-oneapi.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          Write-Host "Installing Intel OneAPI..."
          $url = $env:WINDOWS_BASEKIT_URL
          $components = "intel.oneapi.win.mkl.devel"
          $tempExe = Join-Path $env:TEMP "webimage.exe"

          Write-Host "Downloading installer from $url..."
          curl.exe -L $url -o $tempExe

          Write-Host "Extracting installer..."
          $installerArgs = "-s -x -f webimage_extracted --log extract.log"
          $proc = Start-Process -FilePath $tempExe -ArgumentList $installerArgs -NoNewWindow -Wait -PassThru
          Remove-Item $tempExe -Force

          $bootstrapperPath = Join-Path -Path (Join-Path $PWD "webimage_extracted") "bootstrapper.exe"

          Write-Host "Running bootstrapper..."
          $bootstrapArgs = "-s --action install --components=$components --eula=accept -p=NEED_VS2017_INTEGRATION=0 -p=NEED_VS2019_INTEGRATION=0 -p=NEED_VS2022_INTEGRATION=0 --log-dir=."
          $procBootstrap = Start-Process -FilePath $bootstrapperPath -ArgumentList $bootstrapArgs -NoNewWindow -Wait -PassThru
          Remove-Item -Recurse -Force "webimage_extracted"

      - name: Extract OneAPI version
        shell: powershell
        run: |
          # Extract version from URL (e.g., 2025.2.1 -> 2025.2)
          $url = "${{ env.WINDOWS_BASEKIT_URL }}"
          if ($url -match 'toolkit-(\d+\.\d+)\.\d+') {
            $version = $matches[1]
            echo "ONEAPI_VERSION=$version" >> $env:GITHUB_ENV
            Write-Host "Extracted OneAPI version: $version"
          } else {
            Write-Host "Failed to extract version, using default 2025.2"
            echo "ONEAPI_VERSION=2025.2" >> $env:GITHUB_ENV
          }

      - name: Check branch name
        shell: bash
        run: echo ${{ env.BRANCH_NAME }}
        
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}
      
      - name: Download binaries artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build.yml
          workflow_conclusion: success
          name: dynadjust-windows-mkl
          path: ./artifacts
          branch: ${{ env.BRANCH_NAME }}
          if_no_artifact_found: fail
      
      - name: Extract and prepare binaries
        shell: bash
        run: |
          # Create bin directory
          mkdir -p ./bin/
          
          # Extract the binaries from the downloaded artifact
          if [ -d "./artifacts/DynAdjust-Windows" ]; then
            echo "Found DynAdjust-Windows directory"
            mv ./artifacts/DynAdjust-Windows/* ./bin/
          else
            echo "DynAdjust-Windows directory not found, searching for executables"
            find ./artifacts -type f \( -name "*.exe" -o -name "*.dll" \) -exec mv {} ./bin/ \;
          fi
          
          echo "Contents of ./bin directory:"
          ls -la ./bin/
          
          # Check what executables we have
          echo "Executables found:"
          ls -la ./bin/*.exe 2>/dev/null || echo "No .exe files found"
      
      - name: Run GNSS network test
        working-directory: ./sampleData
        shell: cmd
        run: |
          call "C:\Program Files (x86)\Intel\oneAPI\setvars.bat"
          set PATH=..\bin;%PATH%
          
          :: Run the commands directly using the correct names
          ..\bin\import.exe -n gnss gnss-network.stn gnss-network.msr
          ..\bin\geoid.exe gnss -g gnss-network-geoid.gsb --convert-stn-hts
          ..\bin\adjust.exe gnss --output-adj-msr
          
          :: Check for Chi-Square test values
          findstr /C:"0.843 < 1.165 < 1.170" gnss.simult.adj >nul
          if %ERRORLEVEL% equ 0 (
            echo Chi-Square test values match - test considered successful
            set TEST_RESULT=0
          ) else (
            echo Test FAILED - Chi-Square values do not match expected
            set TEST_RESULT=1
          )
          
          :: Clean up
          del /q *.bms *.bst *.map *.imp *.adj *.xyz *.dbid *.dnaproj *.mtx *.aml *.asl 2>nul
          
          exit /b %TEST_RESULT%
      
      - name: Run urban network test  
        working-directory: ./sampleData
        shell: cmd
        run: |
          call "C:\Program Files (x86)\Intel\oneAPI\setvars.bat"
          set PATH=..\bin;%PATH%
          
          :: Run the commands directly using the correct names
          ..\bin\import.exe -n urban urban-network.stn urban-network.msr
          ..\bin\geoid.exe urban -g urban-network-geoid.gsb --convert-stn-hts
          ..\bin\segment.exe urban --min-inner-stns 50 --max-block-stns 250
          ..\bin\adjust.exe urban --output-adj-msr --phased
          
          :: Check for Chi-Square test values
          findstr /C:"0.901 < 0.857 < 1.104" urban.phased.adj >nul
          if %ERRORLEVEL% equ 0 (
            echo Chi-Square test values match - test considered successful
            set TEST_RESULT=0
          ) else (
            echo Test FAILED - Chi-Square values do not match expected
            set TEST_RESULT=1
          )
          
          :: Clean up
          del /q *.bms *.bst *.seg *.map *.imp *.adj *.xyz *.dbid *.dnaproj *.mtx *.aml *.asl 2>nul
          
          exit /b %TEST_RESULT%

  test_windows_openblas_binaries:
    name: Test Windows OpenBLAS binaries from build workflow
    runs-on: windows-latest
    needs: []  # Don't depend on other test jobs
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
      VCPKG_PACKAGES: boost-geometry boost-process boost-iostreams boost-spirit boost-program-options boost-interprocess xerces-c openblas lapack-reference
      VCPKG_INSTALLATION_ROOT: "C:/vcpkg"
      VCPKG_BINARY_SOURCES: "clear"
    
    steps:
      - name: Show CPU information
        shell: powershell
        run: |
          Write-Host "CPU Information:"
          Get-WmiObject -Class Win32_Processor | Select-Object Name, NumberOfCores, NumberOfLogicalProcessors | Format-List

      - name: Generate cache triggers
        shell: bash
        run: |
          echo VCPKG_HASH=$(echo "${VCPKG_PACKAGES}" | sed "s/ /_/g" | md5sum | cut -f 1 -d" ") >> $GITHUB_ENV

      - name: Cache vcpkg
        id: cache-vcpkg
        uses: actions/cache@v4
        with:
          path: ${{ env.VCPKG_INSTALLATION_ROOT }}/installed
          key: vcpkg-${{ runner.os }}-openblas-${{ env.VCPKG_HASH }}

      - name: Install vcpkg prerequisites
        if: steps.cache-vcpkg.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          vcpkg.exe --triplet=x64-windows install ${{ env.VCPKG_PACKAGES }}
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/.git
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/buildtrees
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/downloads
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/.github
          Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/docs

      - name: Check branch name
        shell: bash
        run: echo ${{ env.BRANCH_NAME }}
        
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}
      
      - name: Download binaries artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build.yml
          workflow_conclusion: success
          name: dynadjust-windows-openblas
          path: ./artifacts
          branch: ${{ env.BRANCH_NAME }}
          if_no_artifact_found: fail
      
      - name: Extract and prepare binaries
        shell: bash
        run: |
          # Create bin directory
          mkdir -p ./bin/
          
          # Extract the binaries from the downloaded artifact
          if [ -d "./artifacts/DynAdjust-Windows" ]; then
            echo "Found DynAdjust-Windows directory"
            mv ./artifacts/DynAdjust-Windows/* ./bin/
          else
            echo "DynAdjust-Windows directory not found, searching for executables"
            find ./artifacts -type f \( -name "*.exe" -o -name "*.dll" \) -exec mv {} ./bin/ \;
          fi
          
          echo "Contents of ./bin directory:"
          ls -la ./bin/
          
          # Check what executables we have
          echo "Executables found:"
          ls -la ./bin/*.exe 2>/dev/null || echo "No .exe files found"
      
      - name: Run GNSS network test
        working-directory: ./sampleData
        shell: cmd
        run: |
          set PATH=..\bin;C:\vcpkg\installed\x64-windows\bin;%PATH%
          
          :: Run the commands directly using the correct names
          ..\bin\import.exe -n gnss gnss-network.stn gnss-network.msr
          ..\bin\geoid.exe gnss -g gnss-network-geoid.gsb --convert-stn-hts
          ..\bin\adjust.exe gnss --output-adj-msr
          
          :: Check for Chi-Square test values
          findstr /C:"0.843 < 1.165 < 1.170" gnss.simult.adj >nul
          if %ERRORLEVEL% equ 0 (
            echo Chi-Square test values match - test considered successful
            set TEST_RESULT=0
          ) else (
            echo Test FAILED - Chi-Square values do not match expected
            set TEST_RESULT=1
          )
          
          :: Clean up
          del /q *.bms *.bst *.map *.imp *.adj *.xyz *.dbid *.dnaproj *.mtx *.aml *.asl 2>nul
          
          exit /b %TEST_RESULT%
      
      - name: Run urban network test  
        working-directory: ./sampleData
        shell: cmd
        run: |
          set PATH=..\bin;C:\vcpkg\installed\x64-windows\bin;%PATH%
          
          :: Run the commands directly using the correct names
          ..\bin\import.exe -n urban urban-network.stn urban-network.msr
          ..\bin\geoid.exe urban -g urban-network-geoid.gsb --convert-stn-hts
          ..\bin\segment.exe urban --min-inner-stns 50 --max-block-stns 250
          ..\bin\adjust.exe urban --output-adj-msr --phased
          
          :: Check for Chi-Square test values
          findstr /C:"0.901 < 0.857 < 1.104" urban.phased.adj >nul
          if %ERRORLEVEL% equ 0 (
            echo Chi-Square test values match - test considered successful
            set TEST_RESULT=0
          ) else (
            echo Test FAILED - Chi-Square values do not match expected
            set TEST_RESULT=1
          )
          
          :: Clean up
          del /q *.bms *.bst *.seg *.map *.imp *.adj *.xyz *.dbid *.dnaproj *.mtx *.aml *.asl 2>nul
          
          exit /b %TEST_RESULT%

  ctest_windows_dyn_mkl:
    name: Build and run ctests on Windows (mkl)
    runs-on: windows-2025
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }} 
      VCPKG_PACKAGES: boost-geometry boost-process boost-iostreams boost-spirit boost-program-options boost-interprocess xerces-c 
      VCPKG_INSTALLATION_ROOT: "C:/vcpkg"
      VCPKG_BINARY_SOURCES: "clear"
      ONEAPI_VERSION: "2025.2"
    
    steps:

    - name: Show CPU information
      shell: powershell
      run: |
        Write-Host "CPU Information:"
        Get-WmiObject -Class Win32_Processor | Select-Object Name, NumberOfCores, NumberOfLogicalProcessors | Format-List

    - name: Generate cache triggers
      shell: bash
      run: |
        echo VCPKG_HASH=$(echo "${VCPKG_PACKAGES}" | sed "s/ /_/g" | md5sum | cut -f 1 -d" ") >> $GITHUB_ENV
        echo ONEAPI_HASH=$(echo "${WINDOWS_BASEKIT_URL}" | md5sum | cut -f 1 -d" ") >> $GITHUB_ENV

    - name: Cache vcpkg
      id: cache-vcpkg
      uses: actions/cache@v4
      with:
        path: ${{ env.VCPKG_INSTALLATION_ROOT }}/installed
        key: vcpkg-${{ runner.os }}-${{ env.VCPKG_HASH }}

    - name: Cache Intel OneAPI
      id: cache-oneapi
      uses: actions/cache@v4
      with:
        path: C:\Program Files (x86)\Intel\oneAPI
        key: intel-oneapi-${{ env.ONEAPI_HASH }}

    - name: Install vcpkg prerequisites
      if: steps.cache-vcpkg.outputs.cache-hit != 'true'
      shell: powershell
      run: |
        vcpkg.exe --triplet=x64-windows install ${{ env.VCPKG_PACKAGES }}
        Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/.git
        Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/buildtrees
        Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/downloads
        Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/.github
        Remove-Item -Recurse -Force ${{ env.VCPKG_INSTALLATION_ROOT }}/docs

    - name: List installed packages
      shell: powershell
      run: vcpkg.exe list

    - name: Install Intel OneAPI
      if: steps.cache-oneapi.outputs.cache-hit != 'true'
      shell: powershell
      run: |
        Write-Host "Installing Intel OneAPI..."
        $url = $env:WINDOWS_BASEKIT_URL
        $components = "intel.oneapi.win.mkl.devel"
        $tempExe = Join-Path $env:TEMP "webimage.exe"

        Write-Host "Downloading installer from $url..."
        curl.exe -L $url -o $tempExe

        Write-Host "Extracting installer..."
        $installerArgs = "-s -x -f webimage_extracted --log extract.log"
        $proc = Start-Process -FilePath $tempExe -ArgumentList $installerArgs -NoNewWindow -Wait -PassThru
        Remove-Item $tempExe -Force

        $bootstrapperPath = Join-Path -Path (Join-Path $PWD "webimage_extracted") "bootstrapper.exe"

        Write-Host "Listing available components..."
        $procBootstrap = Start-Process -FilePath $bootstrapperPath -ArgumentList "--list-components" -NoNewWindow -Wait -PassThru -RedirectStandardOutput components
        get-content components

        Write-Host "Running bootstrapper..."
        $bootstrapArgs = "-s --action install --components=$components --eula=accept -p=NEED_VS2017_INTEGRATION=0 -p=NEED_VS2019_INTEGRATION=0 -p=NEED_VS2022_INTEGRATION=0 --log-dir=."
        $procBootstrap = Start-Process -FilePath $bootstrapperPath -ArgumentList $bootstrapArgs -NoNewWindow -Wait -PassThru
        Remove-Item -Recurse -Force "webimage_extracted"

    - name: Check branch name
      shell: bash
      run: echo ${{ env.BRANCH_NAME }}

    - uses: actions/checkout@v4
      with:
        ref: ${{ env.BRANCH_NAME }}
        path: "./src"

    - name: Download and install xsd
      working-directory: "./src"
      shell: bash
      run: |
        curl.exe -L -O https://www.codesynthesis.com/download/xsd/4.2/libxsd-4.2.0.tar.gz
        tar zxvf libxsd-4.2.0.tar.gz

    - name: Extract OneAPI version
      shell: powershell
      run: |
        # Extract version from URL (e.g., 2025.2.1 -> 2025.2)
        $url = "${{ env.WINDOWS_BASEKIT_URL }}"
        if ($url -match 'toolkit-(\d+\.\d+)\.\d+') {
          $version = $matches[1]
          echo "ONEAPI_VERSION=$version" >> $env:GITHUB_ENV
          Write-Host "Extracted OneAPI version: $version"
        } else {
          Write-Host "Failed to extract version, using default 2025.2"
          echo "ONEAPI_VERSION=2025.2" >> $env:GITHUB_ENV
        }

    - name: Build with CMake
      working-directory: "./src"
      shell: cmd
      run: |
        vcpkg.exe integrate install
        call "C:\Program Files (x86)\Intel\oneAPI\setvars.bat" intel64 vs2022
        set XSDROOT=%cd%\libxsd-4.2.0
        set VPKG_INCLUDE=${{ env.VCPKG_INSTALLATION_ROOT }}\installed\x64-windows\include
        set INCLUDE=%XSDROOT%;%VPKG_INCLUDE%;%INCLUDE%
        set UseEnv=true
        cmake -DUSE_MKL=ON ^
              -DBUILD_TESTING=ON ^
              -DVCPKG_MANIFEST_MODE=OFF ^
              -DCMAKE_TOOLCHAIN_FILE"=${{ env.VCPKG_INSTALLATION_ROOT }}/scripts/buildsystems/vcpkg.cmake" ^
              -G "Visual Studio 17 2022" -A x64 dynadjust
        cmake --build %cd% --config Release --parallel 2
        dir bin\

    - name: Run tests
      working-directory: "./src"
      shell: cmd
      run: |
        call "C:\Program Files (x86)\Intel\oneAPI\setvars.bat"
        ctest --timeout 20 -C Release 2>&1 | powershell -Command "$input | Tee-Object -FilePath ctest_output.log"
        ctest --rerun-failed --output-on-failure
        exit 0

    - name: Parse test results and create annotations
      if: always()
      working-directory: "./src"
      shell: bash
      run: |
        set +e  # Don't exit on error
        if [ -f ctest_output.log ]; then
          # Convert Windows line endings to Unix (try multiple methods)
          if command -v dos2unix &> /dev/null; then
            dos2unix ctest_output.log 2>/dev/null
          elif command -v sed &> /dev/null; then
            sed -i.bak 's/\r$//' ctest_output.log 2>/dev/null || true
          fi
          
          # Find the line with "tests passed" and get everything from there to the end
          SUMMARY_LINE=$(grep -n "tests passed" ctest_output.log 2>/dev/null | head -1 | cut -d: -f1)
          
          if [ -n "$SUMMARY_LINE" ]; then
            # Get the first line (the summary line)
            FIRST_LINE=$(tail -n +$SUMMARY_LINE ctest_output.log | head -1)
            # Get the multiline summary from the tests passed line onwards
            SUMMARY_CONTENT=$(tail -n +$SUMMARY_LINE ctest_output.log | grep -v "Errors while running" | head -20)
            # Replace newlines with %0A for GitHub Actions annotation
            SUMMARY_CONTENT=$(echo "$SUMMARY_CONTENT" | sed ':a;N;$!ba;s/\n/%0A/g')
            
            # Check if there are failed tests
            if grep -q "tests failed" ctest_output.log; then
              echo "::error title=Test results (windows mkl)::$FIRST_LINE - $SUMMARY_CONTENT"
            else
              echo "::notice title=Test results (windows mkl)::$FIRST_LINE - $SUMMARY_CONTENT"
            fi
          else
            echo "::warning title=Test Warning::Could not find test summary in ctest output (tests may still be running or output format changed)"
          fi
        else
          echo "::warning title=Test Warning::Could not find ctest output file (tests may not have run)"
        fi
        exit 0
